

Personal website for auu
Project started 2024-10-22

Based on official Django tutorial -> https://docs.djangoproject.com/en/5.1/intro/tutorial01/

Created with uv. This means that wherever the instructions say to execute e.g. `python manage.py runserver` I actually ran `uv run manage.py runserver`

#### Tutorial 1

Create a new view
https://docs.djangoproject.com/en/5.1/intro/tutorial01/

- Created the directory with `django-admin startproject hello au-django-proj`
- Tested the server with `uv run manage.py runserver`
- Created an app with `uv run manage.py startapp polls`
- Created a simple view by adding the `index` function to `polls/views.py` that returns an `HttpResponse`
- Created a URLconf by creating `polls/urls.py` and populating the list `urlpatterns` with the `path` function
- Linked the polls URLconf to the global URLconf by editing `hello/urls.py`, adding a new `path` to `urlpatterns` with an include for `"polls.urls"`
- Tested the server again and saw that my dummy view is visible at `127.0.0.1:8000/polls`

#### Tutorial 2

https://docs.djangoproject.com/en/5.1/intro/tutorial02/

- Checked out `hello/settings.py` which hosts an extensive list of settings, including `INSTALLED_APPS`, which comes with a bunch of official Django apps by default.
- Set the `TIME_ZONE` in `hello/settings.py`
- Ran `uv run manage.py migrate` to initialise the database with all the apps named in `INSTALLED_APPS`.
- Edited `polls/models.py` to create two new classes representing the Question model and Choice model. These classes had attributes that used the `django.db.models` module to define how they will be stored in the database.
- Edited the list of `INSTALLED_APPS` in `hello/settings.py` to add `polls.apps.PollsConfig`.
- Ran `uv run manage.py makemigrations polls` to create a migration for our new poll. We could just `migrate` but this way we can peer closer at the workings. Note that the created migration is the file `polls/migrations/0001_initial.py`.
- Print out the SQL generated by the migration using `uv run manage.py sqlmigrate polls 0001`. It's a short SQL script that performs `CREATE TABLE` for each model and programs in the constraints we described.
- Ran  `uv run manage.py migrate` to execute the migration.
- Ran `uv run manage.py shell` to open the Python shell in a context that lets us interact with our models:
    - Created a new `Question` object with a `question_text` and `pub_date`
    - Executed its `.save()` method to save it to the database
    - Checked its `.id`, `.question_text` and `.pub_date` attributes
    - Changed the question text and re-saved
    - Called the `Question.objects.all()` method to list all the questions in the DB.
- Realised we forgot to add a `__str__` method to our model classes so we go back and do that in `polls/models.py`
- Added the `was_published_recently()` method to `Question` just to play around with
- Continued to play in the shell. Created a question and assigned it several choices.
    - We used `q.choice_set.create(...)` and `q.choice_set.all()` to set and get the list of choices associated with a question.
    - We saw methods like `q.choice_set.filter` and `Questions.objects.filter` and how they had auto generated fields such as `choice_text__startswith` and `pub_date__year`.
- Used `uv run manage.py createsuperuser` to create an admin account
- Logged into `127.0.0.1:8000/admin` with the admin account and checked out the portal
- Edited `polls/admin.py` to `admin.site.register(Question)` register the Question app. Now it shows up on the admin panel. We can go to `127.0.0.1:8000/admin/polls/questions` and use a nice interface to create and edit Questions.


#### Tutorial 3

https://docs.djangoproject.com/en/5.1/intro/tutorial03/

```
A view is a “type” of web page in your Django application that generally serves a specific function and has a specific template. For example, in a blog application, you might have the following views:
- Blog homepage – displays the latest few entries.
- Entry “detail” page – permalink page for a single entry.
...
In our poll application, we’ll have the following four views:
- Question “index” page – displays the latest few questions.
- Question “detail” page – displays a question text, with no results but with a form to vote.
- Question “results” page – displays results for a particular question.
- Vote action – handles voting for a particular choice in a particular question.
...
In Django, web pages and other content are delivered by views. Each view is represented by a Python function (or method, in the case of class-based views).
...
To get from a URL to a view, Django uses what are known as ‘URLconfs’. A URLconf maps URL patterns to views. This tutorial provides basic instruction in the use of URLconfs, and you can refer to [URL dispatcher](https://docs.djangoproject.com/en/5.1/topics/http/urls/) for more information.
```

- Added functions representing `detail`, `results`, and `vote` to `polls/views.py` that take in a `request` and a parameter `question_id` and return a simple `HttpResponse`
- Updated `polls/urls.py` to add three new URLconfs for the three new views, learning how to use syntax like `"<int:question_id>/results"` to define the URL pattern.

```
When somebody requests a page from your website – say, “/polls/34/”, Django will load the mysite.urls Python module because it’s pointed to by the ROOT_URLCONF setting. It finds the variable named urlpatterns and traverses the patterns in order. After finding the match at 'polls/', it strips off the matching text ("polls/") and sends the remaining text – "34/" – to the ‘polls.urls’ URLconf for further processing. There it matches '<int:question_id>/', resulting in a call to the detail() view.
```

- Created a slightly more advanced index view that pulls data from `Question.all`
- Created the `polls/templates/polls` directory for storing our page templates. Yes that is a confusing path but it's best practise in Django for reasons.
- Created `polls/templates/polls/index.html` template. Learnt Django templating syntax for including logic that will get evaluated by Python:
    - Using `{% if <condition> %} <html> {% else %} <html> {% endif %}` conditional block
    - Using `{% for <object> in <iterable> %} <html> {% endfor %}` looping block
    - Using `{{ <expression> }}` expressions
- Updated the index view function to:
    - Use `django.template.loader` to load in the template
    - Used the template's `template.render` method to generate the contents of the page, and passed that to the returning `HttpResponse`.
- OK but that was a mouthful for a common task, so there's a shorthand. We can import `django.shortcuts.render` and pass it the request, the path to the template, and the context variables. And return the output of that :)
- Next we make a template for `polls/templates/polls/detail.html` and update the detail view function to render it. We don't need to waste breath on declaring context as a variable if we can type the dictionary `{"question":question}` into the parameters of render.
- Add a try-except case to the view that can raise a `django.http.Http404` if the question doesn't exist.
- We learn another shortcut for the common pattern of trying to `get()` an object and throwing `Http404` if it doesn't exist: `django.shortcuts.get_object_or_404`.
- Learnt to use the `{% url '<view name>' <parameter value> %}` syntax in the template that evaluates to a URL.
- We update `polls/urls.py` to include `app_name = "polls"`. This allows us to reference the app name in the template: `% url 'polls:detail' question.id %}`.

#### Tutorial 4


